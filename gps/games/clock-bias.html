<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TOF Shaded Biased Clock with Numbers and Ticks</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-weight: 800;
    font-family: Vazir, sans-serif;
    margin: 20px;
  }
  .clocks {
    display: flex;
    justify-content: center;
    gap: 50px;
    margin-bottom: 20px;
    position: relative;
  }
  canvas {
    background-color: #f8f8f8;
    border: 2px solid #333;
    border-radius: 50%;
    transition: background-color 0.1s;
  }
  .slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
  }
  .signal-line {
    position: absolute;
    width: 4px;
    background-color: orange;
    border-radius: 2px;
    transform-origin: top center;
  }
</style>
</head>
<body>
<div class="clocks" id="clockContainer">
  <div>
    <p style="text-align:center;">ساعت شما</p>
    <canvas id="trueClock" width="200" height="200"></canvas>
  </div>
  <div>
    <p style="text-align:center;">ساعت دوست شما</p>
    <canvas id="biasedClock" width="200" height="200"></canvas>
  </div>
  <div id="signalLine" class="signal-line" style="display:none;"></div>
</div>

<div class="slider-container">
  <label for="timeSlider">زمان</label>
  <input type="range" id="timeSlider" min="-10" max="20" value="-10" style="width:120%">
</div>

<div class="slider-container">
  <label for="biasSlider">انحراف</label>
  <input type="range" id="biasSlider" min="-4" max="4" value="0" style="width:120%">
</div>

<audio id="beepSound">
  <source src="https://freesound.org/people/Robinhood76/sounds/66589/download/66589__robinhood76__00833-alarm-one-shot-beep.wav" type="audio/mpeg">
</audio>

<script>
const trueCanvas = document.getElementById('trueClock');
const biasedCanvas = document.getElementById('biasedClock');
const trueCtx = trueCanvas.getContext('2d');
const biasedCtx = biasedCanvas.getContext('2d');

const timeSlider = document.getElementById('timeSlider');
const simTimeLabel = document.getElementById('simTimeLabel');

const biasSlider = document.getElementById('biasSlider');
const biasValueLabel = document.getElementById('biasValue');

const beepSound = document.getElementById('beepSound');
const signalLine = document.getElementById('signalLine');
const clockContainer = document.getElementById('clockContainer');

let simulationTime = -10; // in seconds
let biasSeconds = 0;

let trueFlash = false;
let biasedFlash = false;
const signalDelay = 5; // seconds
let signals = []; // pending signals [{startTime, arrivedTime, progress}]

biasSlider.addEventListener('input', () => {
  biasSeconds = parseInt(biasSlider.value);
  biasValueLabel.textContent = biasSeconds;
});

timeSlider.addEventListener('input', () => {
  simulationTime = parseFloat(timeSlider.value);
  simTimeLabel.textContent = simulationTime.toFixed(1);
});

function drawClock(ctx, simSec, flash=false, shadingArc=null) {
  const radius = ctx.canvas.width / 2;
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.save();
  ctx.translate(radius, radius);

  // Clock face
  ctx.beginPath();
  ctx.arc(0, 0, radius - 5, 0, 2 * Math.PI);
  ctx.fillStyle = flash ? '#ffeaa7' : '#fff';
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Draw tick marks for hours
  for (let num = 0; num < 12; num++) {
    const angle = num * Math.PI/6;
    const inner = radius * 0.75;
    const outer = radius * 0.85;
    const x1 = inner * Math.cos(angle - Math.PI/2);
    const y1 = inner * Math.sin(angle - Math.PI/2);
    const x2 = outer * Math.cos(angle - Math.PI/2);
    const y2 = outer * Math.sin(angle - Math.PI/2);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = 3; // thick hour marks
    ctx.stroke();
  }

  // Numbers 1-12
  ctx.font = `${radius * 0.15}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (let num = 1; num <= 12; num++) {
    const angle = num * Math.PI / 6 - Math.PI/2;
    const x = Math.cos(angle) * radius * 0.9;
    const y = Math.sin(angle) * radius * 0.9;
    ctx.fillText(num.toString(), x, y);
  }

  // Draw shading arc for TOF
  if (shadingArc) {
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.fillStyle = 'rgba(135,206,250,0.5)'; // light blue
    ctx.arc(0,0,radius-5, shadingArc.startAngle, shadingArc.endAngle);
    ctx.closePath();
    ctx.fill();
  }

  // Time conversion
  let hours = Math.floor(simSec / 3600) % 12;
  if (hours < 0) hours += 12;
  let minutes = Math.floor(simSec / 60) % 60;
  if (minutes < 0) minutes += 60;
  let seconds = simSec % 60;
  if (seconds < 0) seconds += 60;

  drawHand(ctx, (hours + minutes / 60) * 30 * Math.PI / 180, radius * 0.5, 6);
  drawHand(ctx, (minutes + seconds / 60) * 6 * Math.PI / 180, radius * 0.7, 4);
  drawHand(ctx, seconds * 6 * Math.PI / 180, radius * 0.9, 2, 'red');

  ctx.restore();
}

function drawHand(ctx, pos, length, width, color='#000') {
  ctx.beginPath();
  ctx.lineWidth = width;
  ctx.lineCap = 'round';
  ctx.strokeStyle = color;
  ctx.moveTo(0,0);
  ctx.rotate(pos);
  ctx.lineTo(0, -length);
  ctx.stroke();
  ctx.rotate(-pos);
}

function triggerSignal(currentSimTime) {
  beepSound.currentTime = 0;
  beepSound.play();
  trueFlash = true;
  setTimeout(() => { trueFlash = false; }, 200);

  // schedule signal arrival
  signals.push({
    startTime: 0,
    arrivedTime: signalDelay,
    progress: currentSimTime
  });
}

function updateSignalLine() {
  if (signals.length === 0) {
    signalLine.style.display = 'none';
    return;
  }

  const activeSignal = signals[0];
  const progress = Math.min((simulationTime - activeSignal.startTime)/signalDelay, 1);
  if (progress >= 1) {
    biasedFlash = true;
    beepSound.currentTime = 0;
    beepSound.play();
    setTimeout(() => biasedFlash = false, 200);
    signals.shift();
    signalLine.style.display = 'none';
    shading = null; // shading ends when signal received
    return;
  }

  signalLine.style.display = 'block';
  const rectTrue = trueCanvas.getBoundingClientRect();
  const rectBiased = biasedCanvas.getBoundingClientRect();

  const x1 = rectTrue.left + rectTrue.width/2 - clockContainer.getBoundingClientRect().left;
  const y1 = rectTrue.top + rectTrue.height/2 - clockContainer.getBoundingClientRect().top;
  const x2 = rectBiased.left + rectBiased.width/2 - clockContainer.getBoundingClientRect().left;
  const y2 = rectBiased.top + rectBiased.height/2 - clockContainer.getBoundingClientRect().top;

  const x = x1 + (x2 - x1)*progress;
  const y = y1 + (y2 - y1)*progress;
  const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
  const length = Math.hypot(x2 - x1, y2 - y1) * progress;

  signalLine.style.width = `${length}px`;
  signalLine.style.transform = `rotate(${angle}deg)`;
  signalLine.style.left = `${x1}px`;
  signalLine.style.top = `${y1}px`;
}

let lastSimSec = -1;

function update() {
  const simSec = simulationTime;
  const biasedSec = simSec + biasSeconds;

  // Trigger signal when true clock hits 12
  if (Math.floor(simSec) % 60 === 0 && Math.floor(simSec) !== Math.floor(lastSimSec)) {
    triggerSignal(simSec);
  }
  lastSimSec = simSec;

  // Draw true clock
  drawClock(trueCtx, simSec, trueFlash);

  // Draw shading arc for biased clock if active
  let shadingArc = null;
  if (biasedSec >= 0) {
    const startAngle = -Math.PI/2; // 12 o'clock
    const endTime = Math.min(biasedSec, biasSeconds + signalDelay);
    const endAngle = -Math.PI/2 + ( (endTime)*6/180*Math.PI);
    shadingArc = {startAngle, endAngle};
  }

  drawClock(biasedCtx, biasedSec, biasedFlash, shadingArc);

  updateSignalLine();
  requestAnimationFrame(update);
}

update();
</script>

</body>
</html>
