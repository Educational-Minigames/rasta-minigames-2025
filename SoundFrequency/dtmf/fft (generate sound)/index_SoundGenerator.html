<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sound Crop FFT</title>
  <style>
    :root {
      --primary: #000080; /* Navy Blue */
      --primary-hover: #00005a;
      --secondary: #000080; /* Using primary for secondary as well */
      --background: #ffffff;
      --surface: #f8f9fa;
      --surface-hover: #e9ecef;
      --border: #dee2e6;
      --text-primary: #212529;
      --text-secondary: #495057;
      --text-muted: #6c757d;
      --waveform: #000080;
      --spectrum: #000080;
      --selection: rgba(0, 0, 128, 0.15);
      --handle: #000080;
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      --shadow-small: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h3 {
      font-size: 28px;
      font-weight: 700;
      margin: 0 0 32px 0;
      text-align: center;
      color: var(--primary);
    }

    .visualization-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
    }

    .visualization-section:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow), 0 0 24px rgba(0, 0, 128, 0.05);
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0 0 16px 0;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title::before {
      content: "";
      width: 4px;
      height: 18px;
      background: var(--primary);
      border-radius: 2px;
    }

    canvas {
      width: 100%;
      height: 180px;
      background-color: #ffffff;
      border: 1px solid var(--border);
      border-radius: 12px;
      margin-bottom: 16px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
    }

    canvas:hover {
      border-color: var(--primary);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05), 0 0 16px rgba(0, 0, 128, 0.1);
    }

    #intervalBar {
      height: 80px;
      cursor: pointer;
      position: relative;
    }

    #intervalBar:hover {
      border-color: var(--primary);
    }

    .controls {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
      margin: 16px 0;
      padding: 16px;
      background: var(--surface-hover);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .time-display {
      background: var(--background);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 160px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }

    .time-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
    }

    .time-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .time-value {
      color: var(--primary);
      font-weight: 600;
    }

    .instruction {
      flex: 1;
      color: var(--text-muted);
      font-size: 14px;
    }

    .transform-section {
      text-align: center;
      margin: 32px 0;
    }

    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 16px 32px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-small);
      position: relative;
      overflow: hidden;
    }

    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(0, 0, 128, 0.2);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: var(--surface-hover);
      color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .loading-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid var(--text-muted);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .play-controls {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-top: 16px;
      padding: 16px;
      background: var(--surface-hover);
      border: 1px solid var(--border);
      border-radius: 12px;
    }

    .play-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--secondary);
      color: white;
      border: none;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-small);
      transition: all 0.3s ease;
      flex-shrink: 0;
    }

    .play-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 24px rgba(0, 0, 128, 0.2);
    }
    
    .play-bar-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .play-bar {
      height: 8px;
      background: var(--background);
      border: 1px solid var(--border);
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
    }

    .play-progress {
      height: 100%;
      background: var(--secondary);
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s ease;
    }

    .play-handle {
      width: 16px;
      height: 16px;
      background: var(--secondary);
      border: 2px solid white;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 0%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
    }

    .play-handle:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }
    
    .time-indicators {
      display: flex;
      justify-content: space-between;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .spectrum-container {
      position: relative;
    }

    .frequency-tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      color: var(--text-primary);
      pointer-events: none;
      z-index: 1000;
      box-shadow: var(--shadow-small);
      backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .frequency-tooltip.visible {
      opacity: 1;
    }

    .tooltip-freq, .tooltip-mag {
      color: var(--primary);
      font-weight: 600;
    }
    
    .stats {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .stat-card {
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }
    .stat-value {
      display: block;
      font-size: 1.2em;
      font-weight: 600;
      color: var(--primary);
    }
    .stat-label {
      display: block;
      font-size: 0.8em;
      color: var(--text-muted);
    }


    @media (max-width: 768px) {
      body { padding: 12px; }
      h3 { font-size: 24px; margin-bottom: 24px; }
      .visualization-section { padding: 16px; margin-bottom: 16px; }
      canvas { height: 140px; }
      #intervalBar { height: 60px; }
      .controls { flex-direction: column; align-items: stretch; gap: 12px; }
      button { padding: 14px 24px; font-size: 15px; }
      .play-controls { flex-direction: column; gap: 12px; }
      .play-bar-container { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h3>Sound Crop ‚Üí FFT</h3>

    <div class="visualization-section">
      <div class="section-title">üìä Audio Waveform</div>
      <canvas id="plot1"></canvas>
      <div class="play-controls" id="playControls" style="display: none;">
        <button class="play-btn" id="playBtn">‚ñ∂Ô∏è</button>
        <div class="play-bar-container">
          <div class="play-bar" id="playBar">
            <div class="play-progress" id="playProgress"></div>
            <div class="play-handle" id="playHandle"></div>
          </div>
          <div class="time-indicators">
            <span class="current-time" id="currentTime">0:00</span>
            <span class="total-time" id="totalTime">0:00</span>
          </div>
        </div>
      </div>
    </div>

    <div class="visualization-section">
      <div class="section-title">‚úÇÔ∏è Time Selection</div>
      <canvas id="intervalBar"></canvas>
      <div class="controls">
        <div class="time-display">
          <div class="time-row"><span class="time-label">Start:</span><span class="time-value"><span id="tStart">0.00</span> s</span></div>
          <div class="time-row"><span class="time-label">End:</span><span class="time-value"><span id="tEnd">0.00</span> s</span></div>
        </div>
        <div class="instruction">üí° Drag the navy handles on the interval bar to select a segment.</div>
      </div>
    </div>

    <div class="transform-section">
      <button id="transformBtn" disabled><span id="btnText">üîÑ Transform Selected Segment ‚Üí FFT</span></button>
    </div>

    <div class="visualization-section">
      <div class="section-title">üåà Frequency Spectrum</div>
      <div class="spectrum-container">
        <canvas id="plot2"></canvas>
        <div class="frequency-tooltip" id="frequencyTooltip">
          <div>Frequency: <span class="tooltip-freq" id="tooltipFreq">0 Hz</span></div>
          <div>Magnitude: <span class="tooltip-mag" id="tooltipMag">0.00</span></div>
        </div>
      </div>
      <div class="stats" id="spectrumStats" style="display: none;">
        <div class="stat-card"><span class="stat-value" id="peakFreq">--</span><span class="stat-label">Peak Frequency</span></div>
        <div class="stat-card"><span class="stat-value" id="bandwidth">--</span><span class="stat-label">Bandwidth</span></div>
      </div>
    </div>
  </div>

  <script>
  // --- DTMF Sound Generation ---
  function generateDtmfWavUrl() {
      const SECRET_NUMBER = '5551234';
      const TONE_DURATION = 0.1;
      const SILENCE_DURATION = 0.08;
      const SAMPLE_RATE = 44100;
      const AMPLITUDE = 0.5;

      const dtmfFrequencies = {
          '1': [697, 1209], '2': [697, 1336], '3': [697, 1477],
          '4': [770, 1209], '5': [770, 1336], '6': [770, 1477],
          '7': [852, 1209], '8': [852, 1336], '9': [852, 1477],
          '*': [941, 1209], '0': [941, 1336], '#': [941, 1477]
      };

      const totalDuration = (TONE_DURATION + SILENCE_DURATION) * SECRET_NUMBER.length;
      const buffer = new Float32Array(Math.floor(totalDuration * SAMPLE_RATE));
      let offset = 0;

      for (const digit of SECRET_NUMBER) {
          const freqs = dtmfFrequencies[digit];
          const toneSamples = Math.floor(TONE_DURATION * SAMPLE_RATE);
          const silenceSamples = Math.floor(SILENCE_DURATION * SAMPLE_RATE);

          for (let i = 0; i < toneSamples; i++) {
              const t = i / SAMPLE_RATE;
              const sample = (Math.sin(2 * Math.PI * freqs[0] * t) + Math.sin(2 * Math.PI * freqs[1] * t)) / 2 * AMPLITUDE;
              buffer[offset + i] = sample;
          }
          offset += toneSamples + silenceSamples; // Silence is already zeros
      }

      // Convert to WAV
      const dataView = new DataView(new ArrayBuffer(44 + buffer.length * 2));
      const writeString = (view, offset, string) => {
          for (let i = 0; i < string.length; i++) {
              view.setUint8(offset + i, string.charCodeAt(i));
          }
      };

      let pcm = new Int16Array(buffer.length);
      for(let i = 0; i < buffer.length; i++) {
          pcm[i] = Math.min(Math.max(-1, buffer[i]), 1) * 32767;
      }

      writeString(dataView, 0, 'RIFF');
      dataView.setUint32(4, 36 + pcm.length * 2, true);
      writeString(dataView, 8, 'WAVE');
      writeString(dataView, 12, 'fmt ');
      dataView.setUint32(16, 16, true);
      dataView.setUint16(20, 1, true);
      dataView.setUint16(22, 1, true); // Mono
      dataView.setUint32(24, SAMPLE_RATE, true);
      dataView.setUint32(28, SAMPLE_RATE * 2, true);
      dataView.setUint16(32, 2, true);
      dataView.setUint16(34, 16, true);
      writeString(dataView, 36, 'data');
      dataView.setUint32(40, pcm.length * 2, true);
      for (let i = 0; i < pcm.length; i++) {
          dataView.setInt16(44 + i * 2, pcm[i], true);
      }

      const blob = new Blob([dataView], { type: 'audio/wav' });
      return URL.createObjectURL(blob);
  }


  // --- configuration ---
  const SOUND_URL = generateDtmfWavUrl();
  const MAX_FREQUENCY = 2000;

  const plot1 = document.getElementById('plot1'), plot2 = document.getElementById('plot2');
  const intervalBar = document.getElementById('intervalBar');
  const tStartEl = document.getElementById('tStart'), tEndEl = document.getElementById('tEnd');
  const transformBtn = document.getElementById('transformBtn'), btnText = document.getElementById('btnText');
  
  let audioCtx, audioBuffer = null, mono = null, sampleRate = 44100;
  let selection = { start: 0, end: 0 };
  
  function fitCanvas(canvas) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    return ctx;
  }

  function drawWaveform(canvas, data, color='#000080', highlightRange=null) {
    const ctx = fitCanvas(canvas);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
    
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
    ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
      const y = (i / 4) * h;
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }
    
    ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.beginPath();
    const N = data.length, step = Math.max(1, Math.floor(N / w));
    
    for (let x=0; x<w; x++){
      const i0 = Math.floor(x * N / w);
      let min = 1e9, max = -1e9;
      for (let i=i0; i< Math.min(N, i0+step); i++){ const v=data[i]; if(v<min)min=v; if(v>max)max=v; }
      const y1 = (1 - (max * 0.9 + 1)/2) * h;
      const y2 = (1 - (min * 0.9 + 1)/2) * h;
      ctx.moveTo(x, y1); ctx.lineTo(x, y2);
    }
    ctx.stroke();
    
    if (highlightRange) {
      const [s,e] = highlightRange;
      const xs = (s/N)*w, xe = (e/N)*w;
      ctx.fillStyle = 'rgba(0, 0, 128, 0.15)';
      ctx.fillRect(xs,0,xe-xs,h);
    }
  }

  function nextPow2(v){ let p=1; while(p<v) p<<=1; return p; }
  function fft(real, imag) {
    const n = real.length; if (n <= 1) return;
    const levels = Math.floor(Math.log2(n));
    if ((1<<levels) !== n) throw new Error('Length must be power of 2');
    for (let i=0; i<n; i++){
      let j = 0, bit = i;
      for (let k=0; k<levels; k++){ j = (j<<1) | (bit & 1); bit >>= 1; }
      if (j > i){ [real[i], real[j]] = [real[j], real[i]]; [imag[i], imag[j]] = [imag[j], imag[i]]; }
    }
    for (let size = 2; size <= n; size <<= 1) {
      const half = size >> 1, theta = -2 * Math.PI / size;
      const wpr = Math.cos(theta), wpi = Math.sin(theta);
      for (let i=0; i<n; i += size) {
        let wr = 1, wi = 0;
        for (let j=0; j<half; j++){
          const k = i + j, l = k + half;
          const tr = wr * real[l] - wi * imag[l], ti = wr * imag[l] + wi * real[l];
          real[l] = real[k] - tr; imag[l] = imag[k] - ti;
          real[k] += tr; imag[k] += ti;
          const tmp = wr; wr = tmp * wpr - wi * wpi; wi = tmp * wpi + wi * wpr;
        }
      }
    }
  }

  function computeSpectrum(samples, rate) {
    const N0 = samples.length, N = nextPow2(N0);
    const real = new Float32Array(N), imag = new Float32Array(N);
    real.set(samples);
    fft(real, imag);
    const half = N/2;
    const mags = new Float32Array(half);
    for (let k=0; k<half; k++) mags[k] = Math.sqrt(real[k]*real[k] + imag[k]*imag[k]);
    let max=0; for(let i=0;i<half;i++) if(mags[i]>max) max=mags[i];
    if(max>0) for(let i=0;i<half;i++) mags[i]/=max;
    const freqs = new Float32Array(half);
    for(let k=0;k<half;k++) freqs[k] = k*rate/N;
    return {freqs, mags};
  }

  let currentSpectrumData = { freqs: null, mags: null, maxDisplayFreq: 0 };
  function drawSpectrum(canvas, freqs, mags) {
    const ctx = fitCanvas(canvas);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    
    const maxDisplayFreq = Math.min(MAX_FREQUENCY, freqs[freqs.length-1]);
    currentSpectrumData = { freqs, mags, maxDisplayFreq };

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
    
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; ctx.lineWidth = 1; ctx.fillStyle = '#495057';
    ctx.font = '11px -apple-system'; ctx.textAlign = 'center';

    const numTicks = 8, tickSpacing = maxDisplayFreq / numTicks;
    const niceTickSpacing = Math.pow(10, Math.floor(Math.log10(tickSpacing)));
    const tickMultiplier = Math.ceil(tickSpacing / niceTickSpacing);
    const finalTickSpacing = niceTickSpacing * tickMultiplier;

    for (let freq = 0; freq <= maxDisplayFreq; freq += finalTickSpacing) {
      const x = (freq / maxDisplayFreq) * w;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      const freqLabel = freq >= 1000 ? `${(freq/1000).toFixed(1)}k` : `${freq.toFixed(0)}`;
      ctx.fillText(freqLabel, x, 15);
    }
    
    ctx.strokeStyle = '#000080'; ctx.lineWidth = 2; ctx.beginPath();
    const N = mags.length;
    for (let x=0; x<w; x++){
      const f = x/w * maxDisplayFreq;
      const idx = Math.min(N-1, Math.round(f / freqs[freqs.length-1] * (N-1)));
      const y = (1 - mags[idx]) * h;
      if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    
    ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath();
    const fillGradient = ctx.createLinearGradient(0, 0, 0, h);
    fillGradient.addColorStop(0, 'rgba(0, 0, 128, 0.2)');
    fillGradient.addColorStop(1, 'rgba(0, 0, 128, 0)');
    ctx.fillStyle = fillGradient;
    ctx.fill();

    updateSpectrumStats(freqs, mags, maxDisplayFreq);
  }

  function updateSpectrumStats(freqs, mags, maxDisplayFreq) {
    let peakIdx = 0, peakMag = 0;
    const maxIdx = Math.min(mags.length, Math.round(maxDisplayFreq / freqs[freqs.length-1] * (mags.length-1)));
    for(let i=0;i<maxIdx;i++){if(mags[i]>peakMag){peakMag=mags[i];peakIdx=i;}}
    document.getElementById('peakFreq').textContent = freqs[peakIdx].toFixed(1) + ' Hz';
    const threshold=peakMag*0.1; let minFreq=maxDisplayFreq,maxFreq=0;
    for(let i=0;i<maxIdx;i++){if(mags[i]>threshold){minFreq=Math.min(minFreq,freqs[i]);maxFreq=Math.max(maxFreq,freqs[i]);}}
    document.getElementById('bandwidth').textContent = (maxFreq - minFreq).toFixed(1) + ' Hz';
    document.getElementById('spectrumStats').style.display = 'grid';
  }

  const ibCtx = intervalBar.getContext('2d');
  let dragging = null;
  function renderIntervalBar(){
    fitCanvas(intervalBar);
    const w = intervalBar.clientWidth, h = intervalBar.clientHeight;
    ibCtx.fillStyle = '#ffffff'; ibCtx.fillRect(0,0,w,h);
    
    if(mono){
      ibCtx.strokeStyle = '#000080'; ibCtx.lineWidth=1.5; ibCtx.beginPath();
      const N = mono.length, step = Math.max(1, Math.floor(N / w));
      for (let x=0;x<w;x++){
        const i0=Math.floor(x*N/w); let min=1e9,max=-1e9;
        for(let i=i0;i<Math.min(N,i0+step);i++){const v=mono[i]; if(v<min)min=v; if(v>max)max=v;}
        const y1=(1-(max+1)/2)*h, y2=(1-(min+1)/2)*h;
        ibCtx.moveTo(x,y1); ibCtx.lineTo(x,y2);
      }
      ibCtx.stroke();
      
      const startX=(selection.start/audioBuffer.duration)*w, endX=(selection.end/audioBuffer.duration)*w;
      ibCtx.fillStyle = 'rgba(0, 0, 128, 0.2)';
      ibCtx.fillRect(startX, 0, endX - startX, h);
      
      const hr=6;
      ibCtx.fillStyle='#000080';
      ibCtx.beginPath(); ibCtx.arc(startX,h/2,hr,0,Math.PI*2); ibCtx.fill();
      ibCtx.beginPath(); ibCtx.arc(endX,h/2,hr,0,Math.PI*2); ibCtx.fill();
    } else {
      ibCtx.fillStyle='#e9ecef'; ibCtx.fillRect(0,0,w,h);
      ibCtx.fillStyle='#6c757d'; ibCtx.font='14px -apple-system'; ibCtx.textAlign='center';
      ibCtx.fillText('Loading audio...',w/2,h/2);
    }
    tStartEl.textContent = selection.start.toFixed(2);
    tEndEl.textContent = selection.end.toFixed(2);
  }

  function canvasToTime(x){
    const rect = intervalBar.getBoundingClientRect();
    const pos = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
    return pos * audioBuffer.duration;
  }
  intervalBar.addEventListener('pointerdown', (ev)=>{
    if(!audioBuffer) return; ev.preventDefault(); intervalBar.setPointerCapture(ev.pointerId);
    const rect = intervalBar.getBoundingClientRect(), x = ev.clientX - rect.left;
    const startX = (selection.start/audioBuffer.duration)*rect.width;
    const endX = (selection.end/audioBuffer.duration)*rect.width;
    if (Math.abs(x - startX) < 15) dragging = 'start';
    else if (Math.abs(x - endX) < 15) dragging = 'end';
    else {
      dragging = (x < (startX + endX) / 2) ? 'start' : 'end';
      if(dragging==='start') selection.start=canvasToTime(ev.clientX); else selection.end=canvasToTime(ev.clientX);
      if(selection.start>selection.end) [selection.start,selection.end]=[selection.end,selection.start];
      renderIntervalBar();
    }
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!dragging || !audioBuffer) return;
    const t = canvasToTime(ev.clientX);
    if(dragging==='start') selection.start=Math.max(0,Math.min(t,selection.end-0.001));
    else selection.end=Math.min(audioBuffer.duration,Math.max(t,selection.start+0.001));
    renderIntervalBar();
  });
  window.addEventListener('pointerup', ()=>{ if(dragging) dragging=null; });

  let audioSource=null,isPlaying=false,playStartTime=0,playOffset=0,animationFrame=null;
  const playBtn = document.getElementById('playBtn'), playBar = document.getElementById('playBar');
  const playProgress=document.getElementById('playProgress'), playHandle=document.getElementById('playHandle');
  const currentTime=document.getElementById('currentTime'), totalTime=document.getElementById('totalTime');
  const frequencyTooltip=document.getElementById('frequencyTooltip');
  const tooltipFreq=document.getElementById('tooltipFreq'),tooltipMag=document.getElementById('tooltipMag');

  function formatTime(s){const m=Math.floor(s/60);const se=Math.floor(s%60);return `${m}:${se.toString().padStart(2,'0')}`}
  function updatePlayProgress(){
    if(!audioBuffer||!isPlaying)return;
    const elapsed=audioCtx.currentTime-playStartTime+playOffset,duration=audioBuffer.duration;
    const progress=Math.min(elapsed/duration,1);
    playProgress.style.width=`${progress*100}%`; playHandle.style.left=`${progress*100}%`;
    currentTime.textContent=formatTime(elapsed);
    if(progress>=1)stopPlayback(); else animationFrame=requestAnimationFrame(updatePlayProgress);
  }
  function startPlayback(startTime=0){
    if(!audioBuffer||isPlaying)return;
    audioSource=audioCtx.createBufferSource(); audioSource.buffer=audioBuffer;
    audioSource.connect(audioCtx.destination);
    playStartTime=audioCtx.currentTime; playOffset=startTime;
    audioSource.start(0,startTime);
    isPlaying=true; playBtn.textContent='‚è∏Ô∏è'; updatePlayProgress();
    audioSource.onended=()=>{if(isPlaying)stopPlayback()};
  }
  function stopPlayback(){
    if(audioSource){try{audioSource.stop()}catch(err){}} audioSource=null;
    isPlaying=false; playBtn.textContent='‚ñ∂Ô∏è';
    if(animationFrame){cancelAnimationFrame(animationFrame); animationFrame=null;}
  }
  function seekTo(pos){
    const wasPlaying=isPlaying; stopPlayback();
    const seekTime=pos*audioBuffer.duration;
    playProgress.style.width=`${pos*100}%`;playHandle.style.left=`${pos*100}%`;
    currentTime.textContent=formatTime(seekTime);
    if(wasPlaying) startPlayback(seekTime); else playOffset=seekTime;
  }

  playBtn.addEventListener('click', ()=>{if(!audioBuffer)return; if(isPlaying)stopPlayback();else startPlayback(playOffset)});
  let isDraggingPlay=false;
  playBar.addEventListener('pointerdown',ev=>{if(!audioBuffer)return;ev.preventDefault();isDraggingPlay=true;playBar.setPointerCapture(ev.pointerId);const rect=playBar.getBoundingClientRect();seekTo(Math.max(0,Math.min(1,(ev.clientX-rect.left)/rect.width)))});
  window.addEventListener('pointermove',ev=>{if(!isDraggingPlay||!audioBuffer)return;const rect=playBar.getBoundingClientRect();seekTo(Math.max(0,Math.min(1,(ev.clientX-rect.left)/rect.width)))});
  window.addEventListener('pointerup',()=>isDraggingPlay=false);

  plot2.addEventListener('mousemove',ev=>{
    if(!currentSpectrumData.freqs)return;
    const rect=plot2.getBoundingClientRect(),x=ev.clientX-rect.left,y=ev.clientY-rect.top;
    const freq=(x/rect.width)*currentSpectrumData.maxDisplayFreq,N=currentSpectrumData.mags.length;
    const idx=Math.min(N-1,Math.round(freq/currentSpectrumData.freqs[N-1]*(N-1)));
    tooltipFreq.textContent=`${freq.toFixed(1)}Hz`;tooltipMag.textContent=currentSpectrumData.mags[idx].toFixed(3);
    frequencyTooltip.style.left=`${Math.min(rect.width-140,Math.max(10,x+15))}px`;
    frequencyTooltip.style.top=`${Math.min(rect.height-50,Math.max(10,y-10))}px`;
    frequencyTooltip.classList.add('visible');
  });
  plot2.addEventListener('mouseleave',()=>frequencyTooltip.classList.remove('visible'));

  async function loadAudio(){
    transformBtn.disabled=true;
    btnText.innerHTML='<div class="loading-indicator"></div>Loading audio...';
    try {
      audioCtx=new(window.AudioContext||window.webkitAudioContext)();
      const res=await fetch(SOUND_URL);
      if(!res.ok) throw new Error('Failed to fetch sound');
      audioBuffer=await audioCtx.decodeAudioData(await res.arrayBuffer());
      sampleRate=audioBuffer.sampleRate;
      const ch=audioBuffer.numberOfChannels,L=audioBuffer.length; mono=new Float32Array(L);
      for(let i=0;i<L;i++){let s=0;for(let c=0;c<ch;c++)s+=audioBuffer.getChannelData(c)[i]; mono[i]=s/ch}
      selection.start=0;selection.end=audioBuffer.duration;
      drawWaveform(plot1,mono); renderIntervalBar();
      totalTime.textContent=formatTime(audioBuffer.duration); currentTime.textContent=formatTime(0);
      document.getElementById('playControls').style.display='flex';
      const spec=computeSpectrum(mono,sampleRate); drawSpectrum(plot2,spec.freqs,spec.mags);
      transformBtn.disabled=false; btnText.textContent='üîÑ Transform Selected Segment ‚Üí FFT';
    } catch(err){
      console.error(err); alert('Error loading audio: '+err.message);
      btnText.textContent = '‚ùå Failed to load audio';
    }
  }

  transformBtn.addEventListener('click', ()=>{
    if(!mono) return;
    btnText.textContent='üîÑ Processing...'; transformBtn.disabled=true;
    setTimeout(()=>{
      const sSamp=Math.floor(selection.start*sampleRate), eSamp=Math.floor(selection.end*sampleRate);
      const slice=mono.slice(sSamp,eSamp);
      if(slice.length<2){alert('Selection too short');transformBtn.disabled=false;btnText.textContent='üîÑ Transform Selected Segment ‚Üí FFT';return;}
      drawWaveform(plot1,mono,'#000080',[sSamp,eSamp]); renderIntervalBar();
      const spec=computeSpectrum(slice,sampleRate); drawSpectrum(plot2,spec.freqs,spec.mags);
      transformBtn.disabled=false; btnText.textContent='üîÑ Transform Selected Segment ‚Üí FFT';
    }, 50);
  });

  function resizeAll(){
    if (audioBuffer) {
        drawWaveform(plot1, mono, '#000080', null);
        const spec = computeSpectrum(mono, sampleRate);
        drawSpectrum(plot2, spec.freqs, spec.mags);
    }
    renderIntervalBar();
  }
  window.addEventListener('resize', resizeAll);
  document.addEventListener('DOMContentLoaded', loadAudio);
  </script>
</body>
</html>

